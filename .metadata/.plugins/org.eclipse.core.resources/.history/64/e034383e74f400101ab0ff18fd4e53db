#include <stdio.h>
#include "PanTompkins.h"

int PanTompkins(int data) {
    static int filtered[64];
    static int integrated[3];
    static int sample;
    static int peakf = 0;
    static int speakf = 0;
    static int npeakf = 0;
    static int thresholdf1 = 500;  // Initialize with reasonable value
    static int thresholdf2 = 250;
    static int peaki = 0;
    static int speaki = 0;
    static int npeaki = 0;
    static int thresholdi1 = 500;  // Initialize with reasonable value
    static int thresholdi2 = 250;
    static int rr = 0;
    static int rr_avg = 0;
    static int rr_avg_limited = 0;
    static int rr_low_limit = 0;
    static int rr_high_limit = 0;
    static int rr_missed_limit = 0;
    static int n_samples = 0;
    static int r_n_samples = -1;
    static int last_r_n_samples = -1;
    static int bpm = 0;

    static int filtered_idx = 0;
    static int buf_size = 64;
    static int fs = 128;  // Match your timer frequency

    int j = 0;
    int loc_max = 0;
    int idx = 0;
    int filtered_abs = 0;
    int loc_max_idx = 0;

    n_samples++;

    // Filter the signal
    sample = data;
    sample = LowPassFilter(sample);
    sample = HighPassFilter(sample);

    // Store filtered signal
    filtered[filtered_idx] = sample;
    filtered_idx = (filtered_idx + 1) % buf_size;

    // Derivative and squaring
    sample = Derivative(sample);
    sample = sample * sample;
    sample = MovingWindowIntegral(sample);

    // Shift integrated buffer
    for(j = 0; j < 2; j++) {
        integrated[j] = integrated[j+1];
    }
    integrated[2] = sample;

    // Detect peaks
    peaki = PeakDetection(integrated[0], integrated[1], integrated[2]);

    if(peaki != 0) {

        if(peaki >= thresholdi1) {
            // Update signal peak
            speaki = SignalPeak(peaki, speaki);

            // Find corresponding peak in filtered signal
            loc_max = 0;
            loc_max_idx = 0;

            for(j = 0; j < 32; j++) {
                idx = filtered_idx - j - 1;
                if(idx < 0) idx += buf_size;
                filtered_abs = filtered[idx];
                if(filtered_abs < 0) filtered_abs = -filtered_abs;
                if(filtered_abs >= loc_max) {
                    loc_max = filtered_abs;
                    loc_max_idx = j;
                }
            }

            if(loc_max > thresholdf1) {
                // Valid R-peak detected
                speakf = SignalPeak(loc_max, speakf);
                last_r_n_samples = r_n_samples;
                r_n_samples = n_samples - loc_max_idx;

                if(last_r_n_samples >= 0) {
                    rr = r_n_samples - last_r_n_samples;
                    rr_avg = RRAverage1(rr);
                    rr_avg_limited = RRAverage2(rr, rr_avg_limited);

                    // Update limits
                    rr_low_limit = (92 * rr_avg_limited) / 100;
                    rr_high_limit = (116 * rr_avg_limited) / 100;
                    rr_missed_limit = (166 * rr_avg_limited) / 100;

                    // Calculate BPM (with safety check)
                    if(rr_avg > 0) {
                        bpm = (60 * fs) / rr_avg;
                        // Sanity check (30-250 BPM range)
                        if(bpm < 30) bpm = 30;
                        if(bpm > 250) bpm = 250;
                    }
                }
            } else {
                npeakf = SignalPeak(loc_max, npeakf);
            }

            // Check for missed beat
            if((n_samples - r_n_samples) >= rr_missed_limit && rr_missed_limit > 0) {
                if(loc_max > thresholdf2) {
                    speakf = SignalPeak2(loc_max, speakf);
                    last_r_n_samples = r_n_samples;
                    r_n_samples = n_samples - loc_max_idx;

                    if(last_r_n_samples >= 0) {
                        rr = r_n_samples - last_r_n_samples;
                        rr_avg = RRAverage1(rr);
                        rr_avg_limited = RRAverage2(rr, rr_avg_limited);
                        rr_low_limit = (92 * rr_avg_limited) / 100;
                        rr_high_limit = (116 * rr_avg_limited) / 100;
                        rr_missed_limit = (166 * rr_avg_limited) / 100;

                        if(rr_avg > 0) {
                            bpm = (60 * fs) / rr_avg;
                            if(bpm < 30) bpm = 30;
                            if(bpm > 250) bpm = 250;
                        }
                    }
                }
            }

        } else {
            // Below threshold
            npeaki = SignalPeak(peaki, npeaki);

            // Searchback for missed beat
            if((n_samples - r_n_samples) >= rr_missed_limit && rr_missed_limit > 0) {
                if(peaki >= thresholdi2) {
                    speaki = SignalPeak2(peaki, speaki);

                    // Find corresponding peak
                    loc_max = 0;
                    loc_max_idx = 0;

                    for(j = 0; j < 32; j++) {
                        idx = filtered_idx - j - 1;
                        if(idx < 0) idx += buf_size;
                        filtered_abs = filtered[idx];
                        if(filtered_abs < 0) filtered_abs = -filtered_abs;
                        if(filtered_abs >= loc_max) {
                            loc_max = filtered_abs;
                            loc_max_idx = j;
                        }
                    }

                    last_r_n_samples = r_n_samples;
                    r_n_samples = n_samples - loc_max_idx;

                    if(last_r_n_samples >= 0) {
                        rr = r_n_samples - last_r_n_samples;
                        rr_avg = RRAverage1(rr);
                        rr_avg_limited = RRAverage2(rr, rr_avg_limited);
                        rr_low_limit = (92 * rr_avg_limited) / 100;
                        rr_high_limit = (116 * rr_avg_limited) / 100;
                        rr_missed_limit = (166 * rr_avg_limited) / 100;

                        if(rr_avg > 0) {
                            bpm = (60 * fs) / rr_avg;
                            if(bpm < 30) bpm = 30;
                            if(bpm > 250) bpm = 250;
                        }
                    }
                }
            }
        }

        // Update thresholds (THIS WAS MISSING!)
        thresholdf1 = Threshold1(npeakf, speakf);
        thresholdf2 = Threshold2(thresholdf1);
        thresholdi1 = Threshold1(npeaki, speaki);
        thresholdi2 = Threshold2(thresholdi1);
    }

    // Return current BPM
    return bpm;
}


int LowPassFilter(int data) {
    static int y1 = 0, y2 = 0, x[26], n = 12;
    int y0;

    x[0] = x[n + 13] = data;
    y0 = (y1 << 1) - y2 + x[n] - (x[n + 6] << 1) + x[n + 12];
    y2 = y1;
    y1 = y0;
    y0 >>= 5;

    if(--n < 0)
        n = 12;

    return y0;
}

int HighPassFilter(int data) {
    static int y1 = 0, x[66], n = 32;
    int y0;

    x[n] = x[n + 33] = data;
    y0 = y1 + x[n] - x[n + 32];
    y1 = y0;

    if(--n < 0)
        n = 32;

    return(x[n + 16] - (y0 >> 5));
}

int Derivative(int data) {
    int y, i;
    static int x_d[4];

    y = (data << 1) + x_d[3] - x_d[1] - (x_d[0] << 1);
    y >>= 3;

    for (i = 0; i < 3; i++)
        x_d[i] = x_d[i + 1];
    x_d[3] = data;

    return(y);
}

int MovingWindowIntegral(int data) {
    static int x[32], i = 0;
    static long sum = 0;
    long ly;
    int y;

    if(++i == 32)
        i = 0;
    sum -= x[i];
    sum += data;
    x[i] = data;
    ly = sum >> 5;

    if(ly > 32400)
        y = 32400;
    else
        y = (int)ly;

    return(y);
}

int PeakDetection(int prev_prev_data, int prev_data, int data) {
    if((prev_data >= prev_prev_data) && (prev_data > data))
        return prev_data;

    return 0;
}

int SignalPeak(int p, int sp) {
    // 0.125*p + 0.875*sp
    return (p >> 3) + ((7 * sp) >> 3);
}

int SignalPeak2(int p, int sp) {
    // 0.25*p + 0.75*sp
    return (p >> 2) + ((3 * sp) >> 2);
}

int Threshold1(int np, int sp) {
    // np + 0.25*(sp - np)
    return np + ((sp - np) >> 2);
}

int Threshold2(int t1) {
    // 0.5*t1
    return t1 >> 1;
}

int RRAverage1(int rr) {
    static int x[8] = {0};
    static int n = 0;
    int rr_sum = 0;
    int i;

    x[n] = rr;
    n++;
    if(n > 7)
        n = 0;

    for(i = 0; i < 8; i++) {
        rr_sum += x[i];
    }

    return rr_sum >> 3;  // Divide by 8
}

int RRAverage2(int rr, int rr_avg2) {
    static int x[8] = {0};
    static int n = 0;
    int rr_lim_sum = 0;
    int i;

    // Only add if within limits
    int low_limit = (92 * rr_avg2) / 100;
    int high_limit = (116 * rr_avg2) / 100;

    if((rr < high_limit) && (rr > low_limit)) {
        x[n] = rr;
        n++;
        if(n > 7)
            n = 0;
    }

    for(i = 0; i < 8; i++) {
        rr_lim_sum += x[i];
    }

    return rr_lim_sum >> 3;  // Divide by 8
}
